using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Media.Container.Mxf
{
    /// <summary>
    /// Represents the logic necessary to read files in the Material Exchange Format
    /// </summary>
    public class MxfReader : MediaFileStream, IMediaContainer
    {
        /// <summary>
        /// Defines the known types in the Material Exchange Format
        /// </summary>
        public static class Identifier
        {
            public static byte[] HeaderPartition = new byte[] {0x06, 0x0e, 0x2b, 0x34, 0x02, 0x05, 0x01, 0x01, 0x0d, 0x01, 0x02, 0x01, 0x01, 0x02};

            //Klv

            public static byte[] Index = new byte[] { 0x06, 0x0E, 0x2B, 0x34, 0x02, 0x53, 0x01, 0x01, 0x0d, 0x01, 0x02, 0x01, 0x01, 0x10, 0x01, 0x00};

            public static byte[] GenericDescriptior = new byte[] {0x06, 0x0E, 0x2B, 0x34, 0x02, 0x53, 0x01, 0x01, 0x0d, 0x01, 0x01, 0x01, 0x01, 0x01};

            //Metadata Mappings

            public static byte[] ContentStorage = new byte[] { 0x06, 0x0E, 0x2B, 0x34, 0x02, 0x53, 0x01, 0x01, 0x0d, 0x01, 0x01, 0x01, 0x01, 0x01, 0x18, 0x00 };

            public static byte[] SourcePackage = new byte[] { 0x06, 0x0E, 0x2B, 0x34, 0x02, 0x53, 0x01, 0x01, 0x0d, 0x01, 0x01, 0x01, 0x01, 0x01, 0x37, 0x00 };

            public static byte[] Sequence = new byte[] { 0x06, 0x0E, 0x2B, 0x34, 0x02, 0x53, 0x01, 0x01, 0x0d, 0x01, 0x01, 0x01, 0x01, 0x01, 0x0F, 0x00 };

            public static byte[] Preface = new byte[] { 0x06, 0x0E, 0x2B, 0x34, 0x02, 0x53, 0x01, 0x01, 0x0d, 0x01, 0x01, 0x01, 0x01, 0x01, 0x2F, 0x00 };

            public static byte[] Identification = new byte[] { 0x06, 0x0E, 0x2B, 0x34, 0x02, 0x53, 0x01, 0x01, 0x0d, 0x01, 0x01, 0x01, 0x01, 0x01, 0x30, 0x00 };

            public static byte[] SourceClip = new byte[] { 0x06, 0x0E, 0x2B, 0x34, 0x02, 0x53, 0x01, 0x01, 0x0d, 0x01, 0x01, 0x01, 0x01, 0x01, 0x11, 0x00 };

            public static byte[] EssenceContainerData = new byte[] { 0x06, 0x0E, 0x2B, 0x34, 0x02, 0x53, 0x01, 0x01, 0x0d, 0x01, 0x01, 0x01, 0x01, 0x01, 0x23, 0x00 };

            public static byte[] TimelineTrack = new byte[] { 0x06, 0x0E, 0x2B, 0x34, 0x02, 0x53, 0x01, 0x01, 0x0d, 0x01, 0x01, 0x01, 0x01, 0x01, 0x3A, 0x00 };

            public static byte[] TimelineTrackAlt = new byte[] { 0x06, 0x0E, 0x2B, 0x34, 0x02, 0x53, 0x01, 0x01, 0x0d, 0x01, 0x01, 0x01, 0x01, 0x01, 0x3A, 0x00 };

            public static byte[] MaterialPackage = new byte[] { 0x06, 0x0E, 0x2B, 0x34, 0x02, 0x53, 0x01, 0x01, 0x0d, 0x01, 0x01, 0x01, 0x01, 0x01, 0x36, 0x00 };

            public static byte[] IndexSegment = new byte[] { 0x06, 0x0E, 0x2B, 0x34, 0x02, 0x53, 0x01, 0x01, 0x0d, 0x01, 0x01, 0x01, 0x01, 0x10, 0x01, 0x00 };

            public static byte[] GenericDescriptor = new byte[] { 0x06, 0x0E, 0x2B, 0x34, 0x02, 0x53, 0x01, 0x01, 0x0d, 0x01, 0x01, 0x01, 0x01, 0x01, 0x44, 0x00 };

            public static byte[] GenericDataEssenceDescriptor = new byte[] { 0x06, 0x0e, 0x2b, 0x34, 0x02, 0x53, 0x01, 0x01, 0x0d, 0x01, 0x01, 0x01, 0x01, 0x01, 0x5b, 0x00 };

            public static byte[] GenericDataEssenceDescriptorAlt = new byte[] { 0x06, 0x0e, 0x2b, 0x34, 0x02, 0x53, 0x01, 0x01, 0x0d, 0x01, 0x01, 0x01, 0x01, 0x01, 0x5c, 0x00 };

            public static byte[] GenericDataEssenceDescriptorAlt_ = new byte[] { 0x06, 0x0e, 0x2b, 0x34, 0x02, 0x53, 0x01, 0x01, 0x0d, 0x01, 0x01, 0x01, 0x01, 0x01, 0x43, 0x00 };

            public static byte[] GenericSoundEssenceDescriptor = new byte[] { 0x06, 0x0e, 0x2b, 0x34, 0x02, 0x53, 0x01, 0x01, 0x0d, 0x01, 0x01, 0x01, 0x01, 0x01, 0x42, 0x00 };

            public static byte[] CDCIEssenceDescriptor = new byte[] { 0x06, 0x0e, 0x2b, 0x34, 0x02, 0x53, 0x01, 0x01, 0x0d, 0x01, 0x01, 0x01, 0x01, 0x01, 0x28, 0x00 };

            public static byte[] RGBAEssenceDescriptor = new byte[] { 0x06, 0x0e, 0x2b, 0x34, 0x02, 0x53, 0x01, 0x01, 0x0d, 0x01, 0x01, 0x01, 0x01, 0x01, 0x29, 0x00 };

            public static byte[] MPEG2VideoDescriptor = new byte[] { 0x06, 0x0e, 0x2b, 0x34, 0x02, 0x53, 0x01, 0x01, 0x0d, 0x01, 0x01, 0x01, 0x01, 0x01, 0x51, 0x00 };

            public static byte[] WaveAudioDescriptor = new byte[] { 0x06, 0x0e, 0x2b, 0x34, 0x02, 0x53, 0x01, 0x01, 0x0d, 0x01, 0x01, 0x01, 0x01, 0x01, 0x48, 0x00 };

            public static byte[] FileDescriptor = new byte[] { 0x06, 0x0e, 0x2b, 0x34, 0x02, 0x53, 0x01, 0x01, 0x0d, 0x01, 0x01, 0x01, 0x01, 0x01, 0x25, 0x00 };

            public static byte[] GenericPictureEssenceDescriptor = new byte[] { 0x06, 0x0e, 0x2b, 0x34, 0x02, 0x53, 0x01, 0x01, 0x0d, 0x01, 0x01, 0x01, 0x01, 0x01, 0x27, 0x00 };

            public static byte[] AES3PCMDescriptor = new byte[] { 0x06, 0x0e, 0x2b, 0x34, 0x02, 0x53, 0x01, 0x01, 0x0d, 0x01, 0x01, 0x01, 0x01, 0x01, 0x47, 0x00 };

            public static byte[] MXFPartitionPack = new byte[] { 0x06, 0x0e, 0x2b, 0x34, 0x02, 0x53, 0x01, 0x01, 0x0d, 0x01, 0x01, 0x01, 0x01, 0x05, 0x01, 0x00 };

            public static byte[] MXFPartitionPackAlt = new byte[] { 0x06, 0x0e, 0x2b, 0x34, 0x02, 0x53, 0x01, 0x01, 0x0d, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x00 };

            public static byte[] MXFPartitionPack2 = new byte[] { 0x06, 0x0e, 0x2b, 0x34, 0x02, 0x53, 0x01, 0x01, 0x0d, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x00 };

            public static byte[] MXFPartitionPack3 = new byte[] { 0x06, 0x0e, 0x2b, 0x34, 0x02, 0x53, 0x01, 0x01, 0x0d, 0x01, 0x01, 0x01, 0x01, 0x02, 0x03, 0x00 };

            public static byte[] MXFPartitionPack4 = new byte[] { 0x06, 0x0e, 0x2b, 0x34, 0x02, 0x53, 0x01, 0x01, 0x0d, 0x01, 0x01, 0x01, 0x01, 0x02, 0x04, 0x00 };

            public static byte[] MXFPartitionPack5 = new byte[] { 0x06, 0x0e, 0x2b, 0x34, 0x02, 0x53, 0x01, 0x01, 0x0d, 0x01, 0x01, 0x01, 0x01, 0x03, 0x01, 0x00 };

            public static byte[] MXFPartitionPack6 = new byte[] { 0x06, 0x0e, 0x2b, 0x34, 0x02, 0x53, 0x01, 0x01, 0x0d, 0x01, 0x01, 0x01, 0x01, 0x03, 0x02, 0x00 };

            public static byte[] MXFPartitionPack7 = new byte[] { 0x06, 0x0e, 0x2b, 0x34, 0x02, 0x53, 0x01, 0x01, 0x0d, 0x01, 0x01, 0x01, 0x01, 0x03, 0x03, 0x00 };

            public static byte[] MXFPartitionPack8 = new byte[] { 0x06, 0x0e, 0x2b, 0x34, 0x02, 0x53, 0x01, 0x01, 0x0d, 0x01, 0x01, 0x01, 0x01, 0x03, 0x04, 0x00 };

            public static byte[] MXFPartitionPack9 = new byte[] { 0x06, 0x0e, 0x2b, 0x34, 0x02, 0x53, 0x01, 0x01, 0x0d, 0x01, 0x01, 0x01, 0x01, 0x04, 0x02, 0x00 };

            public static byte[] MXFPartitionPack10 = new byte[] { 0x06, 0x0e, 0x2b, 0x34, 0x02, 0x53, 0x01, 0x01, 0x0d, 0x01, 0x01, 0x01, 0x01, 0x04, 0x04, 0x00 };

            public static byte[] TimecodeComponent = new byte[] { 0x06, 0x0E, 0x2B, 0x34, 0x02, 0x53, 0x01, 0x01, 0x0D, 0x01, 0x01, 0x01, 0x01, 0x01, 0x14, 0x00 };

            public static byte[] KLVFill = new byte[] { 0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x03, 0x01, 0x02, 0x10, 0x01, 0x00, 0x00, 0x00 };

            public static byte[] J2KPictureDescriptor = new byte[] { 0x06, 0x0e, 0x2b, 0x34, 0x02, 0x53, 0x01, 0x01, 0x0d, 0x01, 0x01, 0x01, 0x01, 0x01, 0x5a, 0x00 };

            //Codecs

            public static byte[] MPEG2_XDCam = new byte[] { 0x06, 0x0E, 0x2B, 0x34, 0x04, 0x01, 0x01, 0x03, 0x04, 0x01, 0x02, 0x02, 0x01, 0x04, 0x03, 0x00 };

            public static byte[] MPEG2_ML = new byte[] { 0x06, 0x0E, 0x2B, 0x34, 0x04, 0x01, 0x01, 0x03, 0x04, 0x01, 0x02, 0x02, 0x01, 0x01, 0x11, 0x00 };

            public static byte[] MPEG2_D10_PAL = new byte[] { 0x06, 0x0E, 0x2B, 0x34, 0x04, 0x01, 0x01, 0x01, 0x04, 0x01, 0x02, 0x02, 0x01, 0x02, 0x01, 0x01 };

            public static byte[] MPEG2_HL = new byte[] { 0x06, 0x0E, 0x2B, 0x34, 0x04, 0x01, 0x01, 0x03, 0x04, 0x01, 0x02, 0x02, 0x01, 0x03, 0x03, 0x00 };

            public static byte[] MPEG2_HL_422_I = new byte[] { 0x06, 0x0E, 0x2B, 0x34, 0x04, 0x01, 0x01, 0x03, 0x04, 0x01, 0x02, 0x02, 0x01, 0x04, 0x02, 0x00 };

            public static byte[] MPEG4_XDCam_Proxy = new byte[] { 0x06, 0x0E, 0x2B, 0x34, 0x04, 0x01, 0x01, 0x03, 0x04, 0x01, 0x02, 0x02, 0x01, 0x20, 0x02, 0x03 };

            public static byte[] DV_25_PAL = new byte[] { 0x06, 0x0E, 0x2B, 0x34, 0x04, 0x01, 0x01, 0x01, 0x04, 0x01, 0x02, 0x02, 0x02, 0x01, 0x02, 0x00 };

            public static byte[] JPEG2000 = new byte[] { 0x06, 0x0E, 0x2B, 0x34, 0x04, 0x01, 0x01, 0x07, 0x04, 0x01, 0x02, 0x02, 0x03, 0x01, 0x01, 0x00 };

            public static byte[] Raw = new byte[] { 0x06, 0x0E, 0x2B, 0x34, 0x04, 0x01, 0x01, 0x01, 0x04, 0x01, 0x02, 0x01, 0x7F, 0x00, 0x00, 0x00 };

            public static byte[] VC3_DNXD = new byte[] { 0x06, 0x0E, 0x2B, 0x34, 0x04, 0x01, 0x01, 0x01, 0x04, 0x01, 0x02, 0x02, 0x03, 0x02, 0x00, 0x00 };

            public static byte[] AVC_INTRA = new byte[] { 0x06, 0x0E, 0x2B, 0x34, 0x04, 0x01, 0x01, 0x0A, 0x04, 0x01, 0x02, 0x02, 0x01, 0x32, 0x00, 0x00 };

            public static byte[] V210 = new byte[] { 0x06, 0x0E, 0x2B, 0x34, 0x04, 0x01, 0x01, 0x0A, 0x04, 0x01, 0x02, 0x01, 0x01, 0x02, 0x02, 0x00 };

            public static byte[] PCM_S16LE_1 = new byte[] { 0x06, 0x0E, 0x2B, 0x34, 0x04, 0x01, 0x01, 0x01, 0x04, 0x02, 0x02, 0x01, 0x00 };

            public static byte[] PCM_S16LE_2 = new byte[] { 0x06, 0x0E, 0x2B, 0x34, 0x04, 0x01, 0x01, 0x01, 0x04, 0x02, 0x02, 0x01, 0x7F };

            public static byte[] PCM_S16LE_3 = new byte[] { 0x06, 0x0E, 0x2B, 0x34, 0x04, 0x01, 0x01, 0x01, 0x04, 0x02, 0x02, 0x01, 0x01 };

            public static byte[] PCM_S16BE = new byte[] { 0x06, 0x0E, 0x2B, 0x34, 0x04, 0x01, 0x01, 0x07, 0x04, 0x02, 0x02, 0x01, 0x7E };

            public static byte[] PCM_ALAW = new byte[] { 0x06, 0x0E, 0x2B, 0x34, 0x04, 0x01, 0x01, 0x04, 0x04, 0x02, 0x02, 0x02, 0x03, 0x01, 0x01, 0x00 };

            public static byte[] AC3 = new byte[] { 0x06, 0x0E, 0x2B, 0x34, 0x04, 0x01, 0x01, 0x01, 0x04, 0x02, 0x02, 0x02, 0x03, 0x02, 0x01, 0x00 };

            public static byte[] MP2 = new byte[] { 0x06, 0x0E, 0x2B, 0x34, 0x04, 0x01, 0x01, 0x01, 0x04, 0x02, 0x02, 0x02, 0x03, 0x02, 0x05, 0x00 };
        }

        #region Constants

        const int IdentifierSize = 16, MinimumSizeLength = 1, MinimumSize = IdentifierSize + MinimumSizeLength, MultiByteLength = 0x80; //128

        #endregion

        #region Statics

        public static string ToTextualConvention(byte[] identifier, int offset = 0)
        {
            if (identifier == null) return Utility.Unknown;

            byte[] id = offset > 0 ? identifier.Skip(offset).ToArray() : identifier;

            string result;

            if (!IdentifierLookup.TryGetValue(id, out result)) result = Utility.Unknown;

            return result;
        }

        /// <summary>
        /// Decodes the BER Length from the given packet at the given position
        /// </summary>
        public static int DecodeLength(System.IO.Stream stream, out int read)
        {
            read = 0;
            int length = stream.ReadByte();
            ++read;
            if (length >= MultiByteLength)
            {
                length = 0;
                for (int i = 0, end = length & sbyte.MaxValue; i < end; )
                {
                    length = (length << 8) | stream.ReadByte();
                    ++read;
                }
            }
            return length;
        }

        /// <summary>
        /// Holds a cache of all Fields in the Identifiers static type
        /// </summary>
        static Dictionary<byte[], string> IdentifierLookup;

        static MxfReader()
        {
            IdentifierLookup = new Dictionary<byte[], string>();

            foreach (var fieldInfo in typeof(Identifier).GetFields()) IdentifierLookup.Add((byte[])fieldInfo.GetValue(null), fieldInfo.Name);
        }

        #endregion

        //struct Op ?

        public MxfReader(string filename, System.IO.FileAccess access = System.IO.FileAccess.Read) : base(filename, access) { }

        public MxfReader(Uri source, System.IO.FileAccess access = System.IO.FileAccess.Read) : base(source, access) { }

        int? m_TotalFrames, m_Duration;

        public int TotalFrames
        {
            get
            {
                if (!m_TotalFrames.HasValue) ParseHeader();
                return m_TotalFrames.Value;
            }
        }

        public TimeSpan Duration
        {
            get
            {
                if (!m_Duration.HasValue) ParseTimecodeComponent();
                return TimeSpan.FromMilliseconds(m_Duration.Value);
            }
        }

        void ParseHeader()
        {
            using (var headerPartition = Root)
            {
                //read all metaData within Header parition
            }
        }


        void ParseTimecodeComponent()
        {
            using (var timecodeComponent = ReadObject(Identifier.TimecodeComponent, Root.Offset))
            {
                //Read m_Duration timeScale etc...
            }
        }

        public IEnumerable<Node> ReadObjects(long offset = 0, params byte[][] names)
        {
            long position = Position;

            Position = offset;

            foreach (var mxfObject in this)
            {
                if (names == null || names.Count() == 0 || names.Contains(mxfObject.Identifier))
                {
                    yield return mxfObject;
                    continue;
                }
            }

            Position = position;

            yield break;
        }

        public Node ReadObject(byte[] name, long offset = 0)
        {
            long positionStart = Position;

            Node result = ReadObjects(offset, name).FirstOrDefault();

            Position = positionStart;

            return result;
        }

        public Node ReadNext()
        {
            if (Remaining < MinimumSize) return null;

            byte[] identifier = new byte[IdentifierSize];

            Read(identifier, 0, IdentifierSize);

            int sizeLength = 0;

            long length = DecodeLength(this, out sizeLength);

            if (sizeLength <= MinimumSizeLength) throw new InvalidOperationException("Cannot Decode Length");

            return new Node(this, identifier, Position, length, length <= Remaining);
        }

        public override IEnumerator<Node> GetEnumerator() 
        {
            while (Remaining > MinimumSize)
            {
                Node next = ReadNext();
                if (next == null) yield break;
                yield return next;

                //Maybe also Meta and a few others..
                if (next.Identifier.SequenceEqual(Identifier.HeaderPartition)) continue;

                Skip(next.Size);
            }
        }

        List<Track> m_Tracks;

        public override IEnumerable<Track> GetTracks()
        {

            if (m_Tracks != null)
            {
                foreach (Track track in m_Tracks) yield return track;
                yield break;
            }

            var tracks = new List<Track>();

            long position = Position;

            //Get all the TimelineTrack objects
            foreach (var timelineTrackObject in ReadObjects(Root.Offset, Identifier.TimelineTrack, Identifier.TimelineTrackAlt).ToArray()) 
            {
                //Decode trackNumber
                int trackNumber = 0;

                //Decode trackName
                string trackName = string.Empty;

                //Make a trackIdentifier
                byte[] trackIdentifier = new byte[]{ 0x06, 0x0e, 0x2b, 0x34, 0x01, 0x02, 0x01, 0x01, 0x0d, 0x01,
                        0x03, 0x01, (byte)((trackNumber >> 24) & 0xff), (byte)((trackNumber >> 16) & 0xff),
                        (byte)((trackNumber >> 8) & 0xff), (byte)(trackNumber & 0xff) };

                //Get the FileDescriptor for the TimelineTrack
                var fileDescriptor = ReadObject(Identifier.FileDescriptor, timelineTrackObject.Offset);

                Sdp.MediaType mediaType = Sdp.MediaType.unknown;

                //Check for ID to be a known codec or WaveAudioDescriptor??

                //Get AudioFrameDuration and AudioTimeScale if WaveAudioDescriptor

                //Get GenericPictureEssenceDescriptor for width and height

                int totalFrames = 0; double duration = 0;

                //Determine duration
                foreach (var mxfIndexSegmentObject in ReadObjects(timelineTrackObject.Offset, Identifier.IndexSegment))
                {
                    int indexDuration = 0, indexEditRateDen = 0, indexEditRateNum = 0;

                    totalFrames += indexDuration;

                    duration += (double)(indexEditRateDen * indexDuration / indexEditRateNum);
                }
            }

            Position = position;

            m_Tracks = tracks;

            throw new NotImplementedException();
        }

        public override byte[] GetSample(Track track, out TimeSpan duration)
        {
            throw new NotImplementedException();
        }

        public override Node Root
        {
            get { return ReadObject(Identifier.HeaderPartition, 0); }
        }

        public override Node TableOfContents
        {
            get { return ReadObject(Identifier.Index, Root.Offset); }
        }
    }
}
